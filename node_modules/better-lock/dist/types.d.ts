import * as errors from './errors';
declare type IErrorExports = typeof errors;
/**
 * All error names that we can emit
 */
export declare type IErrorName = keyof IErrorExports;
/**
 * User-supplied callback. We support a "canonical" callback, with just error and result,
 * but also old-school callbacks, with varargs return values.
 */
export declare type ICallback<TResult> = TResult extends any[] ? (err: Error | null, ...result: TResult) => void : (err: Error | null, result?: TResult) => void;
/**
 * Function that user will supply as the thing that will be running inside lock.
 * It can either accept a done() function, or return a promise.
 */
export declare type ICallbackExecutor<TResult> = (lockDone: ICallback<TResult>) => void;
export declare type IPromiseExecutor<TResult> = () => Promise<TResult>;
export declare type IExecutor<TResult> = ICallbackExecutor<TResult> | IPromiseExecutor<TResult>;
/**
 * Key types that can be used for a lock.
 */
export declare type ILockKey = string | number | null | undefined;
/**
 * Valid results are anything except functions
 */
export declare type IValidResult = Exclude<any, (...args: any[]) => any>;
export {};
